#!/usr/bin/env bash
set -euo pipefail

sweatshop_parse_target() {
  local target="$1"

  if [[ "$target" == *:* ]]; then
    IFS=: read -r host path <<<"$target"
    echo "$host"
    echo "$path"
  else
    echo ""
    echo "$target"
  fi
}

sweatshop_attach_remote() {
  local host="$1"
  local path="$2"

  gum log -t info "connecting to remote session on $host: $path"
  ssh -t "$host" "zmx attach $path"
}

sweatshop_post_zmx() {
  local sweatshop_path="$1"
  IFS=/ read -ra arg_path_components <<<"$sweatshop_path"

  if [[ "${arg_path_components[1]}" != "worktrees" ]]; then
    return 0
  fi

  local eng_area="${arg_path_components[0]}"
  local repo="${arg_path_components[2]}"
  local worktree="${arg_path_components[3]}"

  local repo_path="$HOME/$eng_area/repos/$repo"
  local worktree_path="$HOME/$sweatshop_path"

  local default_branch
  default_branch="$(git -C "$repo_path" branch --show-current)"

  if [[ -z "$default_branch" ]]; then
    gum log -t warn "could not determine default branch"
    return 0
  fi

  # Check for commits ahead of default branch
  local commits_ahead
  commits_ahead="$(git -C "$worktree_path" rev-list "$default_branch..$worktree" --count 2>/dev/null)" || commits_ahead="0"

  # Check for uncommitted changes (staged, unstaged, untracked) in the worktree
  local worktree_status
  worktree_status="$(git -C "$worktree_path" status --porcelain 2>/dev/null)" || worktree_status=""

  # If no commits ahead and no uncommitted changes, exit cleanly
  if [[ "$commits_ahead" -eq 0 && -z "$worktree_status" ]]; then
    gum log -t info "no changes in worktree $worktree"
    return 0
  fi

  local has_uncommitted=false
  if [[ -n "$worktree_status" ]]; then
    has_uncommitted=true
    gum log -t warn "worktree $worktree has uncommitted changes:"
    git -C "$worktree_path" status --short
  fi

  local action
  if [[ "$has_uncommitted" == true ]]; then
    action="$(gum choose --header "Post-zmx actions for $worktree (uncommitted changes, will not remove worktree):" \
      "Pull + Rebase + Merge + Push" \
      "Rebase + Merge + Push" \
      "Rebase + Merge" \
      "Rebase")" || true
  else
    action="$(gum choose --header "Post-zmx actions for $worktree:" \
      "Pull + Rebase + Merge + Remove worktree + Push" \
      "Rebase + Merge + Remove worktree + Push" \
      "Rebase + Merge + Remove worktree" \
      "Rebase + Merge" \
      "Rebase")" || true
  fi

  if [[ -z "$action" ]]; then
    return 0
  fi

  if [[ "$action" == Pull* ]]; then
    if ! git -C "$repo_path" pull; then
      gum log -t error "pull failed"
      return 1
    fi
    gum log -t info "pulled $default_branch from origin"
  fi

  if ! git -C "$worktree_path" rebase "$default_branch"; then
    gum log -t error "rebase failed"
    return 1
  fi
  gum log -t info "rebased $worktree onto $default_branch"

  if [[ "$action" == *Rebase ]]; then
    return 0
  fi

  # Stash any tracked changes in the repo before merging
  local repo_stashed=false
  if ! git -C "$repo_path" diff --quiet 2>/dev/null || ! git -C "$repo_path" diff --cached --quiet 2>/dev/null; then
    git -C "$repo_path" stash push -m "sweatshop: auto-stash before merge of $worktree"
    repo_stashed=true
    gum log -t info "stashed changes in $repo_path"
  fi

  if ! git -C "$repo_path" merge "$worktree" --ff-only; then
    gum log -t error "merge failed (not fast-forward)"
    if [[ "$repo_stashed" == true ]]; then
      git -C "$repo_path" stash pop
      gum log -t info "restored stashed changes in $repo_path"
    fi
    return 1
  fi
  gum log -t info "merged $worktree into $default_branch"

  # Restore stashed changes in repo
  if [[ "$repo_stashed" == true ]]; then
    git -C "$repo_path" stash pop
    gum log -t info "restored stashed changes in $repo_path"
  fi

  if [[ "$action" == *Merge ]]; then
    return 0
  fi

  if [[ "$action" == *"Remove worktree"* ]]; then
    git -C "$repo_path" worktree remove "$HOME/$sweatshop_path"
    gum log -t info "removed worktree $worktree"

    if ! git -C "$repo_path" branch -D "$worktree"; then
      gum log -t error "failed to delete branch $worktree"
      return 1
    fi
    gum log -t info "deleted branch $worktree"
  fi

  if [[ "$action" == *Push ]]; then
    if ! git -C "$repo_path" push origin "$default_branch"; then
      gum log -t error "push failed"
      return 1
    fi
    gum log -t info "pushed $default_branch to origin"
  fi
}

sweatshop_create_worktree() {
  local eng_area="$1"
  local repo_path="$2"
  local worktree_path="$3"

  mkdir -p "$worktree_path"
  git -C "$repo_path" worktree add "$worktree_path"

  sweatshop_apply_rcm_worktrees_overlay "$eng_area" "$worktree_path"
}

sweatshop_apply_rcm_worktrees_overlay() {
  local eng_area="$1"
  local worktree_path="$2"

  local rcm_worktrees="$HOME/$eng_area/rcm-worktrees"
  if [[ ! -d "$rcm_worktrees" ]]; then
    return 0
  fi

  while IFS= read -r src; do
    local rel="${src#"$rcm_worktrees/"}"
    local dest="$worktree_path/.$rel"
    if [[ ! -f "$dest" ]]; then
      mkdir -p "$(dirname "$dest")"
      cp "$src" "$dest"
    fi
  done < <(find "$rcm_worktrees" -type f)
}

sweatshop_attach_existing() {
  local sweatshop_path="$1"

  zmx attach "$sweatshop_path" || true
  sweatshop_post_zmx "$sweatshop_path"
}

sweatshop_attach_to_path() {
  local sweatshop_path="$1"
  IFS=/ read -ra arg_path_components <<<"$sweatshop_path"

  local eng_area="${arg_path_components[0]}"
  local repo="${arg_path_components[2]}"

  if [[ "${arg_path_components[1]}" != "worktrees" ]]; then
    gum log -t error "invalid path provided: $sweatshop_path"
    return 1
  fi

  local repo_path="$HOME/$eng_area/repos/$repo"
  local worktree_path="$HOME/$sweatshop_path"

  sweatshop_create_worktree "$eng_area" "$repo_path" "$worktree_path"

  cd "$worktree_path"
  zmx attach "$sweatshop_path" || true

  sweatshop_post_zmx "$sweatshop_path"
}

sweatshop_status_branch() {
  local branch_path="$1"
  local branch_name="$2"
  local indent="${3:-  }"

  local dirty=""
  local porcelain
  porcelain="$(git -C "$branch_path" status --porcelain 2>/dev/null)" || porcelain=""

  if [[ -n "$porcelain" ]]; then
    local modified added deleted untracked
    modified="$(grep -c '^.M' <<<"$porcelain" || true)"
    added="$(grep -c '^A' <<<"$porcelain" || true)"
    deleted="$(grep -c '^.D' <<<"$porcelain" || true)"
    untracked="$(grep -c '^??' <<<"$porcelain" || true)"

    local parts=()
    [[ "$modified" -gt 0 ]] && parts+=("${modified}M")
    [[ "$added" -gt 0 ]] && parts+=("${added}A")
    [[ "$deleted" -gt 0 ]] && parts+=("${deleted}D")
    [[ "$untracked" -gt 0 ]] && parts+=("${untracked}?")
    dirty="$(
      IFS=' '
      echo "${parts[*]}"
    )"
  else
    dirty="clean"
  fi

  local remote_status=""
  local upstream
  upstream="$(git -C "$branch_path" rev-parse --abbrev-ref '@{upstream}' 2>/dev/null)" || upstream=""

  if [[ -n "$upstream" ]]; then
    local left_right
    left_right="$(git -C "$branch_path" rev-list --left-right --count '@{upstream}...HEAD' 2>/dev/null)" || left_right=""

    if [[ -n "$left_right" ]]; then
      local behind ahead
      behind="$(echo "$left_right" | cut -f1)"
      ahead="$(echo "$left_right" | cut -f2)"

      local parts=()
      [[ "$ahead" -gt 0 ]] && parts+=("↑${ahead}")
      [[ "$behind" -gt 0 ]] && parts+=("↓${behind}")

      if [[ ${#parts[@]} -gt 0 ]]; then
        remote_status="$(
          IFS=' '
          echo "${parts[*]}"
        ) ${upstream}"
      else
        remote_status="≡ ${upstream}"
      fi
    fi
  fi

  local last_commit
  last_commit="$(git -C "$branch_path" log -1 --format='%cs' 2>/dev/null)" || last_commit="n/a"

  local last_modified
  local newest_file
  newest_file="$(find "$branch_path" -not -path '*/.git/*' -type f -printf '%T@\n' 2>/dev/null | sort -rn | head -1)" || newest_file=""

  if [[ -n "$newest_file" ]]; then
    last_modified="$(date -d "@${newest_file%%.*}" '+%Y-%m-%d' 2>/dev/null)" || last_modified="n/a"
  else
    last_modified="n/a"
  fi

  printf "%s%-20s %-12s %-25s commit: %s  modified: %s\n" \
    "$indent" "$branch_name" "$dirty" "$remote_status" "$last_commit" "$last_modified"
}

sweatshop_status_repo() {
  local eng_area="$1"
  local repo="$2"
  local repo_path="$HOME/$eng_area/repos/$repo"

  if [[ ! -d "$repo_path/.git" ]]; then
    return 0
  fi

  gum log -t info "$eng_area/repos/$repo"

  local main_branch
  main_branch="$(git -C "$repo_path" branch --show-current 2>/dev/null)" || main_branch=""

  if [[ -n "$main_branch" ]]; then
    sweatshop_status_branch "$repo_path" "$main_branch"
  fi

  local worktrees_dir="$HOME/$eng_area/worktrees/$repo"
  if [[ -d "$worktrees_dir" ]]; then
    local worktree
    for worktree in "$worktrees_dir"/*/; do
      [[ -d "$worktree" ]] || continue
      local wt_name
      wt_name="$(basename "$worktree")"
      sweatshop_status_branch "$worktree" "$wt_name" "    "
    done
  fi
}

sweatshop_status() {
  local found=false

  local eng_dir
  for eng_dir in "$HOME"/eng*/repos/; do
    [[ -d "$eng_dir" ]] || continue
    local eng_area
    eng_area="$(basename "$(dirname "$eng_dir")")"

    local repo_dir
    for repo_dir in "$eng_dir"*/; do
      [[ -d "$repo_dir" ]] || continue
      local repo
      repo="$(basename "$repo_dir")"
      sweatshop_status_repo "$eng_area" "$repo"
      found=true
    done
  done

  if [[ "$found" == false ]]; then
    gum log -t info "no repos found"
  fi
}

sweatshop_usage() {
  gum log -t error "usage: sweatshop <subcommand> [args]"
  gum log -t info "subcommands:"
  gum log -t info "  attach [target]  attach to a worktree session"
  gum log -t info "  status           show status of all repos and worktrees"
  return 1
}

sweatshop_attach() {
  case "$#" in
    0)
      local sweatshop_path="${PWD#"$HOME"/}"

      if [[ -d "$HOME/$sweatshop_path" ]]; then
        sweatshop_attach_existing "$sweatshop_path"
      else
        sweatshop_attach_to_path "$sweatshop_path"
      fi
      ;;
    1)
      local target="$1"
      local parse_result
      parse_result="$(sweatshop_parse_target "$target")"
      local host path
      host="$(sed -n '1p' <<<"$parse_result")"
      path="$(sed -n '2p' <<<"$parse_result")"

      if [[ -n "$host" ]]; then
        sweatshop_attach_remote "$host" "$path"
        return $?
      fi

      if [[ -d "$HOME/$target" ]]; then
        sweatshop_attach_existing "$target"
        return $?
      fi

      sweatshop_attach_to_path "$target"
      ;;
    *)
      gum log -t error "more than one argument provided"
      return 1
      ;;
  esac
}

sweatshop_main() {
  local subcommand="${1:-}"

  case "$subcommand" in
    attach)
      shift
      sweatshop_attach "$@"
      ;;
    status)
      shift
      sweatshop_status "$@"
      ;;
    *)
      sweatshop_usage
      ;;
  esac
}

if [[ "${BASH_SOURCE[0]}" == "$0" ]]; then
  sweatshop_main "$@"
fi
