#!/usr/bin/env bash
set -euo pipefail

z_parse_target() {
  local target="$1"

  if [[ "$target" == *:* ]]; then
    IFS=: read -r host path <<<"$target"
    echo "$host"
    echo "$path"
  else
    echo ""
    echo "$target"
  fi
}

z_attach_remote() {
  local host="$1"
  local path="$2"

  gum log -t info "connecting to remote session on $host: $path"
  ssh -t "$host" "zmx attach $path"
}

z_post_zmx() {
  local z_path="$1"
  IFS=/ read -ra arg_path_components <<<"$z_path"

  if [[ "${arg_path_components[1]}" != "worktrees" ]]; then
    return 0
  fi

  local eng_area="${arg_path_components[0]}"
  local repo="${arg_path_components[2]}"
  local worktree="${arg_path_components[3]}"

  local repo_path="$HOME/$eng_area/repos/$repo"
  local worktree_path="$HOME/$z_path"

  local default_branch
  default_branch="$(git -C "$repo_path" branch --show-current)"

  if [[ -z "$default_branch" ]]; then
    gum log -t warn "could not determine default branch"
    return 0
  fi

  # Check for commits ahead of default branch
  local commits_ahead
  commits_ahead="$(git -C "$worktree_path" rev-list "$default_branch..$worktree" --count 2>/dev/null)" || commits_ahead="0"

  # Check for uncommitted changes (staged, unstaged, untracked) in the worktree
  local worktree_status
  worktree_status="$(git -C "$worktree_path" status --porcelain 2>/dev/null)" || worktree_status=""

  # If no commits ahead and no uncommitted changes, exit cleanly
  if [[ "$commits_ahead" -eq 0 && -z "$worktree_status" ]]; then
    gum log -t info "no changes in worktree $worktree"
    return 0
  fi

  local has_uncommitted=false
  if [[ -n "$worktree_status" ]]; then
    has_uncommitted=true
    gum log -t warn "worktree $worktree has uncommitted changes:"
    git -C "$worktree_path" status --short
  fi

  local action
  if [[ "$has_uncommitted" == true ]]; then
    action="$(gum choose --header "Post-zmx actions for $worktree (uncommitted changes, will not remove worktree):" \
      "Pull + Rebase + Merge + Push" \
      "Rebase + Merge + Push" \
      "Rebase + Merge" \
      "Rebase")" || true
  else
    action="$(gum choose --header "Post-zmx actions for $worktree:" \
      "Pull + Rebase + Merge + Remove worktree + Push" \
      "Rebase + Merge + Remove worktree + Push" \
      "Rebase + Merge + Remove worktree" \
      "Rebase + Merge" \
      "Rebase")" || true
  fi

  if [[ -z "$action" ]]; then
    return 0
  fi

  if [[ "$action" == Pull* ]]; then
    if ! git -C "$repo_path" pull; then
      gum log -t error "pull failed"
      return 1
    fi
    gum log -t info "pulled $default_branch from origin"
  fi

  if ! git -C "$worktree_path" rebase "$default_branch"; then
    gum log -t error "rebase failed"
    return 1
  fi
  gum log -t info "rebased $worktree onto $default_branch"

  if [[ "$action" == *Rebase ]]; then
    return 0
  fi

  # Stash any tracked changes in the repo before merging
  local repo_stashed=false
  if ! git -C "$repo_path" diff --quiet 2>/dev/null || ! git -C "$repo_path" diff --cached --quiet 2>/dev/null; then
    git -C "$repo_path" stash push -m "z: auto-stash before merge of $worktree"
    repo_stashed=true
    gum log -t info "stashed changes in $repo_path"
  fi

  if ! git -C "$repo_path" merge "$worktree" --ff-only; then
    gum log -t error "merge failed (not fast-forward)"
    if [[ "$repo_stashed" == true ]]; then
      git -C "$repo_path" stash pop
      gum log -t info "restored stashed changes in $repo_path"
    fi
    return 1
  fi
  gum log -t info "merged $worktree into $default_branch"

  # Restore stashed changes in repo
  if [[ "$repo_stashed" == true ]]; then
    git -C "$repo_path" stash pop
    gum log -t info "restored stashed changes in $repo_path"
  fi

  if [[ "$action" == *Merge ]]; then
    return 0
  fi

  if [[ "$action" == *"Remove worktree"* ]]; then
    git -C "$repo_path" worktree remove "$HOME/$z_path"
    gum log -t info "removed worktree $worktree"

    if ! git -C "$repo_path" branch -d "$worktree"; then
      gum log -t error "failed to delete branch $worktree"
      return 1
    fi
    gum log -t info "deleted branch $worktree"
  fi

  if [[ "$action" == *Push ]]; then
    if ! git -C "$repo_path" push origin "$default_branch"; then
      gum log -t error "push failed"
      return 1
    fi
    gum log -t info "pushed $default_branch to origin"
  fi
}

z_has_session() {
  zmx list | awk '{split($1, a, "="); print a[2]}' | grep -q "$1" >/dev/null
}

z_create_worktree() {
  local eng_area="$1"
  local repo_path="$2"
  local worktree_path="$3"

  mkdir -p "$worktree_path"
  git -C "$repo_path" worktree add "$worktree_path"

  local default_branch
  default_branch="$(git -C "$repo_path" branch --show-current)"

  if [[ -n "$default_branch" ]]; then
    git -C "$worktree_path" branch --set-upstream-to="origin/$default_branch"
    gum log -t info "set upstream to origin/$default_branch"
  fi

  z_apply_rcm_worktrees_overlay "$eng_area" "$worktree_path"
}

z_apply_rcm_worktrees_overlay() {
  local eng_area="$1"
  local worktree_path="$2"

  local rcm_worktrees="$HOME/$eng_area/rcm-worktrees"
  if [[ ! -d "$rcm_worktrees" ]]; then
    return 0
  fi

  while IFS= read -r src; do
    local rel="${src#"$rcm_worktrees/"}"
    local dest="$worktree_path/.$rel"
    if [[ ! -f "$dest" ]]; then
      mkdir -p "$(dirname "$dest")"
      cp "$src" "$dest"
    fi
  done < <(find "$rcm_worktrees" -type f)
}

z_attach_existing() {
  local z_path="$1"

  zmx attach "$z_path" || true
  z_post_zmx "$z_path"
}

z_attach_to_path() {
  local z_path="$1"
  IFS=/ read -ra arg_path_components <<<"$z_path"

  local eng_area="${arg_path_components[0]}"
  local repo="${arg_path_components[2]}"

  if [[ "${arg_path_components[1]}" != "worktrees" ]]; then
    gum log -t error "invalid path provided: $z_path"
    return 1
  fi

  local repo_path="$HOME/$eng_area/repos/$repo"
  local worktree_path="$HOME/$z_path"

  z_create_worktree "$eng_area" "$repo_path" "$worktree_path"

  cd "$worktree_path"
  zmx attach "$z_path" || true

  z_post_zmx "$z_path"
}

z_main() {
  case "$#" in
    0)
      local z_path="${PWD#"$HOME"/}"

      if [[ -d "$HOME/$z_path" ]] || z_has_session "$z_path"; then
        z_attach_existing "$z_path"
      else
        z_attach_to_path "$z_path"
      fi
      ;;
    1)
      local target="$1"
      local parse_result
      parse_result="$(z_parse_target "$target")"
      local host path
      host="$(sed -n '1p' <<<"$parse_result")"
      path="$(sed -n '2p' <<<"$parse_result")"

      if [[ -n "$host" ]]; then
        z_attach_remote "$host" "$path"
        return $?
      fi

      if [[ -d "$HOME/$target" ]] || z_has_session "$target"; then
        z_attach_existing "$target"
        return $?
      fi

      z_attach_to_path "$target"
      ;;
    *)
      gum log -t error "more than one argument provided"
      return 1
      ;;
  esac
}

if [[ "${BASH_SOURCE[0]}" == "$0" ]]; then
  z_main "$@"
fi
